

# 编译原理课程实验报告

**Date : 2020-5-31**

> 课程名称：编译原理
>
> 编译器名称：WeakenC
>
> 成员：
>
> ​            鞠滢        STUDENT ID：317010xxxx   计算机科学与技术
>
> ​            刘非凡    STUDENT ID：3170102894   信息安全
>
> ​            章雨婷    STUDENT ID：3170102582   信息安全
>
> 任课老师：李莹



#### 课程设计题目要求

##### 1、目的

+ 掌握词法分析，语法分析和代码生成方法

##### 2、内容

+ 用lex写出一个类C或者类PACAL某个语言的 词法分析器
+ 用YACC的分析方法完成对某一个语法分析
+ 生成语法树和中间代码
+ 生成目标代码（加分项）

##### 3、要求

+ 提交实验报告，包括词法分析部分的正规表达式描述、数据结构、原理以及实现，中间代码的格式、数据结构描述以及中间代码生成的实现（目标代码的生成）
+ 提交源代码
+ 要求结果能用可视化的方法表示出来



# Contents #

* Outline
{:toc}


















## Chapter 1 : 编译器简介

### 1.1 编译器简介

说下编译器干了些啥

### 1.2 编译器功能介绍

具体实现了什么功能

### 1.3 总体架构和运行环境

#### 1.3.1 总体架构

画代码结构调用关系图

#### 1.3.2 运行环境

环境要求：flex bison g++11 python3

## Chapter 2 : 词法分析

### 2.1 总体描述

&emsp;词法分析器是从左到右逐个字符地对源程序进行扫描，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。词法分析器部分由Lex实现。

### 2.2 正规表达式描述

#### 2.2.1  数据表示

先列实现的数据类型：eg. string，int，double，char

| 类别 | 内容 |
| ---- | ---- |
| 字符 |      |
| 数字 |      |
|      |      |

然后放.l的正则表达式定义代码：

```

```

#### 2.2.2  关键字

| 类别     | 内容 |
| -------- | ---- |
| bool     |      |
| char     |      |
| int      |      |
| double   |      |
| switch   |      |
| case     |      |
| continue |      |
| break    |      |
| do       |      |
| while    |      |
| if       |      |
| else     |      |
| for      |      |
| goto     |      |
| return   |      |
| void     |      |
| true     |      |
| false    |      |

然后放.l的正则表达式定义代码：

```

```

#### 2.2.3  操作符

先列实现的操作符类型

| 类别       | 内容                               |
| ---------- | ---------------------------------- |
| 单目运算符 | + - ~ !                            |
| 关系运算符 | < > <= >= != ==                    |
| 算术运算符 | + - * / % \| ^ &                   |
| 逻辑运算符 | \|\| &&                            |
| 移位运算   | >> <<                              |
| 赋值运算符 | = += -= *= /= %= &= ^= \|= <<= >>= |

表示方式：

```

```

#### 2.2.4  注释及其他

注释表示：

```

```



## Chapter 3 : 语法分析

### 3.1 总体描述

语法分析是编译过程的核心部分。它的任务是在词法分析识别出单词符号串的基础上，分析并判定程序的语法结构是否符合语法规则。语法分析部分由YACC在基于我们定义的树的结构的基础上实现。


### 3.2 文法描述

#### 3.2.1 变量定义文法

实现的语句：

```c
int xxx;
```

表示方式：

```
$$ = create_tree("declaration",2,$1,$2); //?
```





#### 3.2.2 赋值及操作运算符文法



#### 3.2.3 选择文法



#### 3.2.4 循环文法



#### 3.2.5 函数调用文法







### 3.3 数据结构
#### 3.3.1 语法树结构定义

gramtree定义：

```c++

```



#### 3.3.2 函数说明

语法树每个函数功能描述：







### 3.4 原理及实现

.y和tree.cpp调用模式

语法树例子和图：

## Chapter 4 : 中间代码

### 4.1 总体描述



### 4.2 中间代码格式说明

| Grammer                       | Description                                                  |
| ----------------------------- | ------------------------------------------------------------ |
| LABEL label_name :            | 声明标签                                                     |
| left := right                 | 赋值语句                                                     |
|                               | right: var binomial_op var \| var \| unary_op var \| *temp \| &temp \| array_element \| CALL f(var1,var2,var3...) |
|                               | var: temp \| constant                                        |
|                               | left: temp \| array_element \| *temp                         |
|                               | array_item: temp[var]                                        |
|                               | temp必须只含有小写英文字母、数字、下划线，且首字符是字母     |
| GOTO label1                   | 无条件跳转至标签处                                           |
| IF var GOTO label1            | 条件语句                                                     |
| IFNOT var GOTO label1         | 条件语句                                                     |
| RETURN var                    | 函数返回                                                     |
| MALLOC var1[size]             | 申请大小为size的内存空间，并将申请到的连续内存首地址赋给var1 |
| CALL f (var1,var2,var3...)    | 调用函数并不需要返回值                                       |
| Function f(var1,var2,var3...) | 声明函数f                                                    |

### 4.3 数据结构

#### 4.3.1 数据结构定义

符号表 各种操作

#### 4.3.2 语义分析

##### 4.3.2.1 变量定义

parser里面具体的数据结构

##### 4.3.2.2 赋值与操作运算符



##### 4.3.2.3 选择



##### 4.3.2.4 循环



##### 4.3.2.5 函数调用



#### 4.3.3 中间代码优化



### 4.4. 原理及实现

例子



## Chapter 5 : 目标代码

### 5.1 总体描述



### 5.2 目标代码格式说明



### 5.3 数据结构

#### 5.3.1 寄存器结构



#### 5.3.2 寄存器分配方式



### 5.4. 原理及实现





## Chapter 6 : 运行方式和结果

### 6.1 运行方式



### 6.2 demo结果






## Chapter 7 : 开发困难及解决方案

### 7.1 困难1

* 困难

  

* 解决方案

  

### 7.2 困难2

* 困难

  

* 解决方案

  

### 7.3 困难3

* 困难

  

* 解决方案

  

### 7.4 困难4

* 困难

  

* 解决方案

  




## Chapter 8 : 总结

未实现的功能还有很多，例如：

* 

总体基础功能基本上实现了
